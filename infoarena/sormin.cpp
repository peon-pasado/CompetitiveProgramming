/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag dp, bitmask
 * @idea
 *      - we can optimize with suffix bits first approach
 *      - use two power trick and solve simple subset sum
 *      with log(n/5000) factor (the maximum).
 *      - use bitmask to divide by 32 the complexity
 *      - use simple dp with two power trick to
 *      rebuild the answer.
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#include <bitset>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < mod? a+b : a+b-mod;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%mod;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a);
        a = mul(a, a);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 5e5 + 10;

class sormin {
public:
    void solveOne(istream& in, ostream& out) {
      int n, s;
      in >> n >> s;
      vi a(5000 + 1);
      re(i, 0, n) {
        int x;
        in >> x;
        a[x] += 1;
      }
      auto f = [&](int min_or)->bool {
          bitset<50001> dp;
          dp[0] = 1;
          re(idx, 1, 5001) {
            if (a[idx] == 0 || (min_or & idx) != idx) {
              continue;
            }
            int m = a[idx];
            for (int x = 0; (1<<x) <= m; ++x) {
              dp |= (dp << (idx * (1<<x)));
              m -= (1<<x);
            }
            dp |= (dp << (idx * m));
          }
          return dp[s];
      };
      int min_or = (1<<13)-1;
      for (int i = 12; i >= 0; --i) {
          if (f(min_or ^ (1<<i))) {
            min_or ^= (1<<i);
          }
      }
      bool dp[50005];
      ii tr[50005];
      memset(dp, 0, sizeof dp);
      dp[0] = 1;
      for (int i = 5000; i >= 1; --i) {
        if (a[i] == 0 || (min_or & i) != i) {
          continue;
        }
        int m = a[i];
        for (int x = 0; (1<<x) <= m; ++x) {
          int t = i * (1<<x);
          for (int k = s; k >= t; --k) {
            if (dp[k] || !dp[k-t]) {
              continue;
            }
            dp[k] = 1;
            tr[k] = {i, 1<<x};
          }
          m -= (1<<x);
        }
        if (m > 0) {
          int t = i * m;
          for (int k = s; k >= t; --k) {
            if (dp[k] || !dp[k-t]) {
              continue;
            }
            dp[k] = 1;
            tr[k] = {i, m};
          }
        }
        if (dp[s]) {
          break;
        }
      }
      vector<int> res;
      while (s > 0) {
        auto q = tr[s];
        re(i, 0, q.second) {
          res.eb(q.first);
        }
        s -= q.first * q.second;
      }
      out << min_or << " " << sz(res) << endl;
      trav(e, res) out << e << " ";
      out << endl;
    }

    void solve(istream& in, ostream& out) {
        out.precision(10);
        out << fixed;
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    freopen("sormin.in", "r", stdin);
    freopen("sormin.out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    sormin solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}