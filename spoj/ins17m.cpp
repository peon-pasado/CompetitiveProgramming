/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 */

#include <bits/stdc++.h>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
const int mod = 1e9 + 7;
const int maxn = 1e6 + 10;
bool composite[maxn];
vector<int> prime;
int mu[maxn];
int cnt[maxn];
int number_of[maxn];
int value[maxn];
int a[maxn];

int mul(ll a, ll b) {
    return a * b % mod;
}

int add(int a, int b) {
    return a + b >= mod ? a + b - mod : a + b;
}

void mobius(int n) {
    mu[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!composite[i]) {
            mu[i] = -1;
            prime.emplace_back(i);
        }
        for (int p : prime) {
            if (p * i > n) break;
            composite[p * i] = 1;
            if (i % p == 0) {
                mu[p * i] = 0;
                break;
            } else {
                mu[p * i] = -mu[i];
            }
        }
    }
}

class X {
public:

    void solveOne(istream& in, ostream& out) {
        int n;
        long long k;
        in >> n >> k;
        for (int i = 0; i < n; ++i) {
            in >> a[i];
            cnt[a[i]] += 1;
        }
        const int N = 1000000;
        for (int i = 1; i <= N; ++i) {
            for (int j = 2 * i; j <= N; j += i) {
                cnt[i] += cnt[j];
            }
        }
        mobius(N);
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j * i <= N; ++j) {
                number_of[i] = add(number_of[i], mul(mul(mod + mu[j],
                                   mul(cnt[i * j], (cnt[i * j] - 1))), (mod+1)/2));
            }
        }
        using ii = pair<int, int>;
        function<ii(int)> f = [&](int n)->ii {
            if (n == 0) return {0, 1};
            if (n & 1) {
                auto q = f(n-1);
                swap(q.first, q.second);
                q.second = add(q.first, q.second);
                return q;
            }
            auto q = f(n>>1);
            int a = add(mul(q.first, q.first), mul(q.second, q.second));
            int b = add(mul(q.first, q.second), mul(q.first, add(q.second, mod - q.first)));
            return {b, a};
        };
        auto ex = [](ll a, ll b)->int {
            ll r = 1;
            while (b > 0) {
                if (b & 1) r = r*1ll*a%2000000016;
                a = a*1ll*a%2000000016;
                b >>= 1;
            }
            return r;
        };
        for (int i = 1; i <= N; ++i) {
            value[i] = mul(number_of[i], f(ex(i, k)).first);
        }
        int ans = 0;
        for (int i = 1; i <= N; ++i) {
            ans = add(ans, value[i]);
        }
        out << ans << endl;
    }

    void solve(istream& in, ostream& out) {
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	X solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}