/**
 * @author Miguel Mini
 * @tag scc, dag
 * @idea
 *     - If we join all the nodes
 *     connected by 0-edges, two
 *     nodes connected by 1-edges
 *     can't be in the same group.
 *
 *     - Groups connected by 1-edges
 *     form a DAG.
 *
 *     - If we separate each group into
 *     strongly connected components, the
 *     SCC-DAG have at most one node with
 *     indegree 0
 *
 *     - we must print the groups in the
 *     topological order generated by inverting
 *     the 1-edges and each group in topological
 *     sort (note that the nodes should not be
 *     in a continuous sequence, so this order is
 *     fine).
 */

#include <bits/stdc++.h>
#define trav(e, v) for (auto e : v)
#define rep(i, n) for (int i = 0; i < n; ++i)
#define reu(i, s, n) for (int i = s; i < n; ++i)
#define red(i, s, n) for (int i = s; i >= n; --i)
#define all(x) x.begin(), x.end()
#define rall(X) x.begin(), x.end()
#define len(x) (int)x.size()
using namespace std;
typedef long long ll;
typedef pair<int, int> ii;
typedef vector<int> vi;

const int maxn = 2e4 + 10;
struct Node {
	int u, w;
};
vector<Node> g[maxn];
vector<int> t[maxn];
int comp1[maxn], comp2[maxn];
int deg[maxn];
int ncomps;
bool valid = true;
stack<int> z;
vector<int> o;
int ts[maxn];
int T;

int dfs(int x, int l, int comp[]) {
    z.push(x);
    int low = ts[x] = ++T;
    for (auto edge: g[x]) if (edge.w <= l && comp[edge.u] < 0)
        low = min(low, ts[edge.u] ?: dfs(edge.u, l, comp));
    if (low == ts[x]) {
        int it;
        do {
            it = z.top(); z.pop();
            comp[it] = ncomps;
        } while (x != it);
        ncomps++;
    }
    if (l == 2) o.push_back(x);
    return ts[x] = low;
}

int color[maxn];
vector<int> c2[maxn];
stack<int> color_order[maxn];
void dfs_color(int x, int c) {
	color[x] = c;
	for (auto u : t[x]) {
		if (!color[u]) dfs_color(u, c);
		else if (color[u] != color[x]) {
			valid = false;
		}
	}
	for (int v : c2[x]) {
		color_order[comp1[v]].push(v);
	}
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin >> n >> m;
    vector<ii> e1;
    rep(i, m) {
    	int a, b, c;
    	cin >> a >> b >> c;
    	--a; --b;
    	if (c) {
    		g[b].push_back({a, 1});
    		e1.emplace_back(b, a);
    	} else {
    		g[a].push_back({b, 0});
    		g[b].push_back({a, 2});
    	}
    }
    memset(comp1, -1, sizeof comp1);
    rep(i, n) {
    	if (comp1[i] < 0) {
    		dfs(i, 2, comp1);
    	}
    }
    trav(pi, e1) {
    	if (comp1[pi.first] == comp1[pi.second]) {
    		return puts("-1"), 0;
    	}
    }
    memset(comp2, -1, sizeof comp2);
    T = 0;
    ncomps = 0;
    memset(ts, 0, sizeof ts);
    rep(i, n) {
    	if (comp2[i] < 0) {
    		dfs(i, 0, comp2);
    	}
    }
    rep(i, n) {
    	c2[comp2[i]].push_back(i);
    }
    rep(i, n) {
    	for (auto edge : g[i]) {
    		if (edge.w == 0) {
    			if (comp2[i] != comp2[edge.u]) {
    				t[comp2[i]].push_back(comp2[edge.u]);
    				deg[comp2[edge.u]] += 1;
    			}
    		}
    	}
    }
    int C = 0;
    rep(i, ncomps) {
    	if (deg[i] == 0) {
    		dfs_color(i, ++C);
    	}
    }
    if (!valid) return puts("-1"), 0;
    reverse(all(o));
    trav(i, o) {
    	int q = color_order[comp1[i]].top();
    	color_order[comp1[i]].pop();
    	printf("%d ", q + 1);
    }
    puts("");
    return 0;
}