/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag dp, rebuild
 * @idea
 *      - use simple dp to count all valid strings
 *      - from memo we can build final strings.
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
const int mod = 1e9 + 7;
const int inf = 1.2e9;
int m, k;
ll r;
string dna;
const int maxN = 5e4 + 5;
ll memo[maxN][10][4];
bool vis[maxN][10][4];

ll dp(int pos, int t, int last) {
  if (t < 0) return 0;
  if (pos == m) return memo[pos][t][last] = 1;
  if (vis[pos][t][last]) {
    return memo[pos][t][last];
  }
  vis[pos][t][last] = 1;
  ll& ans = memo[pos][t][last] = 0;
  if (dna[pos] == 4) {
    for (int i = 0; i < 4; ++i) {
      ans += dp(pos+1, t - (last > i), i);
    }
  } else {
    ans = dp(pos+1, t - (last > dna[pos]), dna[pos]);
  }
  return ans;
}

class APIO_08_dna {
public:
    void solveOne(istream& in, ostream& out) {
      in >> m >> k >> r;
      in >> dna;
      map<char, int> id;
      char inv_id[5];
      id['A'] = 0; inv_id[0] = 'A';
      id['C'] = 1; inv_id[1] = 'C';
      id['G'] = 2; inv_id[2] = 'G';
      id['T'] = 3; inv_id[3] = 'T';
      id['N'] = 4;
      for (auto& c : dna) {
        c = id[c];
      }
      memset(vis, 0, sizeof vis);
      dp(0, k-1, 0);
      int pos = 0, t = k-1, last = 0;
      long long cnt = 0;
      string response = "";
      while (pos != m) {
        int cur = dna[pos];
        if (dna[pos] == 4) {
          for (int i = 0; i < 4; ++i) {
            if (t == 0 and last > i) continue;
            ll temp = memo[pos+1][t-(last>i)][i];
            if (cnt + temp < r) {
              cnt += temp;
            } else {
              cur = i;
              break;
            }
          }
        }
        response += inv_id[cur];
        pos += 1;
        t -= last > cur;
        last = cur;
      }
      out << response << endl;
    }

    void solve(istream& in, ostream& out) {
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	APIO_08_dna solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}