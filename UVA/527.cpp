/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < mod? a+b : a+b-mod;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%mod;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a);
        a = mul(a, a);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 5e5 + 10;

template <class T> int sgn(T x) { return (x > 0) - (x < 0); }
template<class T>
struct Point {
    typedef Point P;
    T x, y;
    explicit Point(T x=0, T y=0) : x(x), y(y) {}
    bool operator<(P p) const {
      return x < p.x || (abs(x-p.x) < 1e-8 && y < p.y);
    }
    bool operator>(P p) const {return p < *this;}
    bool operator<=(P p) const {return !(*this>p);}
    bool operator>=(P p) const {return !(*this<p);}
    bool operator==(P p) const {
      return abs(x-p.x) < 1e-8 && abs(y-p.y) < 1e-8;}
    bool operator!=(P p) const {
      return !(*this == p);}
    P operator+(P other) const {return P(x+other.x, y+other.y);}
    P operator-(P other) const {return P(x-other.x, y-other.y);}
    P operator*(T c) const {return P(x*c, y*c);}
    P operator/(T c) const {return P(x/c, y/c);}
    friend P operator*(T c, const P p) {return p*c;}
    T operator*(P other) const {return x*other.x + y*other.y;}
    T operator^(P other) const {return x*other.y - y*other.x;}
    T dot(P other) const {return (*this)*other;}
    T cross(P other) const {return (*this)^other;}
    T cross(P a, P b) const {return (a-*this).cross(b-*this);}
    T norm2() const {return x*x + y*y;}
    double norm() const {return sqrt((double)norm2());}
    double dist(P p) {return (p-(*this)).norm();}
    // angle to x-axis in interval [-pi, pi]
    double angle() const {return atan2(y, x);}
    P unit() const {return *this/norm();} // makes dist()=1
    P perp() const {return P(-y, x);} // rotates +90 degrees
    P normal() const {return perp().unit();}
    // returns point rotated 'a' radians ccw around the origin
    P rotate(double a) const {
      return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a));}
    P rotate(Point other, double a) const {
      return (*this-other).rotate(a) + other;}
    friend istream& operator>>(istream& is, P& other) {
      return is >> other.x >> other.y;}
    friend ostream& operator<<(ostream& os, P other) {
      return os << other.x << " " << other.y;}
};

template<class T>
struct Segment {
    Point<T> a, ab;
    bool isLine;
    Segment() {}
    Segment(Point<T> a, Point<T> b, bool isLine=false):
            a(a), ab(b - a), isLine(isLine) {}
    Point<T> b() {return a + ab;}
    int intercept(Segment q, Point<T>& res) {
      enum type {NONE=0, ONE, IN};
      T s = ab^q.ab;
      if (abs(s) < 1e-8) { //parallel
        return 0;
        if (abs((q.a - a)^ab) < 1e-8) { //same line
          if (q.isLine || isLine) return IN; //una incluye a la otra
          auto la = a, lb = b();
          auto ra = q.a, rb = q.b();
          if (la > lb) swap(la, lb);
          if (ra > rb) swap(ra, rb);
          res = max(la, ra);
          return min(lb, rb) - max(la, ra) >= Point<T>(-1e-8, -1e-8);
        }
        return 0;
      }
      T t1 = q.ab^(a - q.a);
      T t2 = ab^(q.a - a);
      if (s > 0) t2 = -t2;
      if (s < 0) t1 = -t1, s = -s;
      bool r1 = (0 <= t1 && t1 <= abs(s)) || isLine;
      bool r2 = (0 <= t2 && t2 <= abs(s)) || q.isLine;
      res = a + t1 * ab / s; //need double
      return (r1 && r2) ? ONE : NONE;
    }
    double dist(Point<T> p) {
      if (!isLine) {
        if ((p - a) * ab <= 0) return p.dist(a);
        if ((p - b()) * ab >= 0) return p.dist(b());
      }
      return abs((p - a) ^ ab) / ab.norm();
    }
    double dist(Segment p) {
      if (intercept(p)) return 0;
      if (isLine && p.isLine) return abs((ab ^ (p.a - a))) / ab.norm();
      double d1 = min(p.dist(a), p.dist(b()));
      double d2 = min(dist(p.a), dist(p.b()));
      if (isLine) return d2;
      if (p.isLine) return d1;
      return min(d1, d2);
    }
};

vector<Segment<double>> lines;
vector<Point<double>> vertices;

void init() {
  lines.clear();
  vertices.clear();
  Point<double> A(0, 0);
  Point<double> B(0, 1000);
  Point<double> C(1000, 1000);
  Point<double> D(1000, 0);
  vertices.eb(A);
  vertices.eb(B);
  vertices.eb(C);
  vertices.eb(D);
  lines.eb(Segment<double>(A, B, 1));
  lines.eb(Segment<double>(B, C, 1));
  lines.eb(Segment<double>(C, D, 1));
  lines.eb(Segment<double>(D, A, 1));
}

bool equals(Segment<double> p, Segment<double> q) {
  return (p.a == q.a && p.b() == q.b()) || (p.a == q.b() && p.b() == q.a);
}

class UVA527 {
public:
    void solveOne(istream& in, ostream& out) {
      int n;
      in >> n;
      init();
      re(i, 0, n) {
        Point<double> a, b;
        in >> a >> b;
        Segment<double> line(a, b);
        bool fun = 1;
        trav(l, lines) {
          if (equals(line, l)) {
            fun = 0;
          }
        }
        if (fun) {
          vertices.eb(a);
          vertices.eb(b);
          lines.eb(Segment<double>(a, b, 1));
        }
      }
      auto inbox = [](Point<double> p)->bool {
        return p.x > -1e-8 && p.x <= 1000 + 1e-8 && p.y > -1e-8 && p.y <= 1000 + 1e-8;
      };
      re(i, 0, sz(lines)) {
        re(j, i+1, sz(lines)) {
          Point<double> temp;
          if (lines[i].intercept(lines[j], temp) && inbox(temp)) {
            vertices.eb(temp);
          }
        }
      }
      sort(all(vertices));
      vertices.resize(unique(all(vertices)) - vertices.begin());
      int e = 0;
      re(i, 0, sz(lines)) {
          int temp = 0;
          trav(p, vertices) {
            if (lines[i].dist(p) < 1e-8) {
              temp += 1;
            }
          }
          e += temp - 1;
      }
      out << e - sz(vertices) + 1 << endl;
    }
    void solve(istream& in, ostream& out) {
        out.precision(10);
        out << fixed;
        int testNumber = 1;
        in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            if (tc != 1) out << endl;
            solveOne(in, out);
        }
    }
};


int main() {
    //freopen("in", "r", stdin);
    //freopen("out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    UVA527 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}