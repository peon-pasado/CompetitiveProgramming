/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < mod? a+b : a+b-mod;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%mod;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (r > 0) {
        if (b&1) r = mul(r, a);
        a = mul(a, a);
        b >>= 1;
    }
    return r;
}

template <class T>
struct Point {
    T x, y;
    Point() {}
    Point(T x, T y): x(x), y(y) {}
    Point operator+(Point q) {return Point(x+q.x, y+q.y);}
    Point operator-(Point q) {return Point(x-q.x, y-q.y);}
    T operator*(Point q) {return x*q.x + y*q.y;}
    T operator^(Point q) {return x*q.y - y*q.x;}
    T norm2() {return (*this) * (*this);}
    double norm() {return sqrt(norm2());}
    friend double distance(Point p, Point q) {return (p-q).norm();}
};

template<class T>
struct Segment {
    Point<T> a, ab;
    Segment() {}
    Segment(Point<T> a, Point<T> b) : a(a), ab(b - a) {}
    Point<T> b() { return a + ab; }
    bool intercept(Segment q) {
      T s = ab^q.ab;
      if (s == 0) return 0;
      T t1 = q.ab^(a - q.a);
      T t2 = ab^(q.a - a);
      if (s < 0) t1 = -t1;
      if (s > 0) t2 = -t2;
      bool r1 = 0 <= t1 && t1 <= abs(s);
      bool r2 = 0 <= t2 && t2 <= abs(s);
      return r1 && r2;
    }
};

template<class T>
double distance(Point<T> p, Segment<T> s) {
  if (((p - s.a) * s.ab) <= 0) return distance(p, s.a);
  if (((p - s.b()) * s.ab) >= 0) return distance(p, s.b());
  return abs((p - s.a) ^ s.ab) / s.ab.norm();
}

template<class T>
double distance(Segment<T> p, Segment<T> q) {
  if (p.intercept(q)) return 0;
  double d1 = min(distance(p.a, q), distance(p.b(), q));
  double d2 = min(distance(q.a, p), distance(q.b(), p));
  return min(d1, d2);
}

const int inf = 1.2e9;
const int maxn = 5e5 + 10;

class UVA10514 {
public:
    void solveOne(istream& in, ostream& out) {
      int r1, r2, n;
      in >> r1 >> r2 >> n;
      vector<Point<int>> A(r1), B(r2);
      re(i, 0, r1) {
        int x, y;
        in >> x >> y;
        A[i] = Point<int>(x, y);
      }
      re(i, 0, r2) {
        int x, y;
        in >> x >> y;
        B[i] = Point<int>(x, y);
      }
      vector<vector<Point<int>>> C(n + 2);
      C[0] = A;
      C[1] = B;
      re(i, 0, n) {
        int m;
        in >> m;
        re(j, 0, m) {
          int x, y;
          in >> x >> y;
          C[i + 2].push_back(Point<int>(x, y));
        }
      }
      auto calc_dist = [&](int a, int b) {
        double min_dist = 1e9;
        re(i, 0, sz(C[a])) {
          if (i + 1 == sz(C[a]) && a <= 1) break;
          Segment<int> s1(C[a][i], C[a][(i+1)%sz(C[a])]);
          re(j, 0, sz(C[b])) {
            if (j + 1 == sz(C[b]) && b <= 1) break;
            Segment<int> s2(C[b][j], C[b][(j+1)%sz(C[b])]);
            min_dist = min(min_dist, distance(s1, s2));
          }
        }
        return min_dist;
      };
      int m = n + 2;
      vector<vector<double>> min_dist(m, vector<double>(m));
      re(i, 0, m) {
        re(j, i+1, m) {
          double d = calc_dist(i, j);
          min_dist[i][j] = min_dist[j][i] = d;
        }
      }
      re(k, 0, m) {
        re(i, 0, m) {
          re(j, 0, m) {
            min_dist[i][j] = min(min_dist[i][j], min_dist[i][k] + min_dist[k][j]);
          }
        }
      }
      out << min_dist[0][1] << endl;
    }

    void solve(istream& in, ostream& out) {
        out.precision(3);
        out << fixed;
        int testNumber = 1;
        in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    //freopen("in", "r", stdin);
    //freopen("out", "w", stdout);
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    UVA10514 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}