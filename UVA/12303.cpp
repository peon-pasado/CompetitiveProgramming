/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#include <bitset>
#include <stack>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define rep(x, y) for (int x=0; x<y; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < m? a+b : a+b-m;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%m;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a, m);
        a = mul(a, a, m);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 5e5 + 10;

template<class T> struct Point3D {
    typedef Point3D P;
    typedef const P& R;
    T x, y, z;
    explicit Point3D(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}
    bool operator<(R p) const {
      return tie(x, y, z) < tie(p.x, p.y, p.z); }
    bool operator==(R p) const {
      return tie(x, y, z) == tie(p.x, p.y, p.z); }
    P operator+(R p) const { return P(x+p.x, y+p.y, z+p.z); }
    P operator-(R p) const { return P(x-p.x, y-p.y, z-p.z); }
    P operator*(T d) const { return P(x*d, y*d, z*d); }
    P operator/(T d) const { return P(x/d, y/d, z/d); }
    T dot(R p) const { return x*p.x + y*p.y + z*p.z; }
    P cross(R p) const {
      return P(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x);
    }
    T dist2() const { return x*x + y*y + z*z; }
    double dist() const { return sqrt((double)dist2()); }
    //Azimuthal angle (longitude) to x-axis in interval [-pi, pi]
    double phi() const { return atan2(y, x); }
    //Zenith angle (latitude) to the z-axis in interval [0, pi]
    double theta() const { return atan2(sqrt(x*x+y*y),z); }
    P unit() const { return *this/(T)dist(); } //makes dist()=1
    //returns unit vector normal to *this and p
    P normal(P p) const { return cross(p).unit(); }
    //returns point rotated 'angle' radians ccw around axis
    P rotate(double angle, P axis) const {
      double s = sin(angle), c = cos(angle); P u = axis.unit();
      return u*dot(u)*(1-c) + (*this)*c - cross(u)*s;
    }
};
using Point = Point3D<double>;

const double eps = 1e-8;
const double PI = acos(-1);
struct Plane {
    double a, b, c, d;
    Plane(double a=0, double b=0, double c=0, double d=0): a(a), b(b), c(c), d(d) {}
    Plane(Point p1, Point p2, Point p3) {
      auto q = (p2 - p1).cross(p3 - p1).unit();
      a = q.x;
      b = q.y;
      c = q.z;
      d = -(a * p1.x + b * p1.y + c * p1.z);
    }
    vector<Point> decompose() {
      vector<Point> r;
      double t1 = 1. * rand() / RAND_MAX;
      double t2 = 1. * rand() / RAND_MAX;
      double t3 = 1. * rand() / RAND_MAX;
      if (abs(a) > eps) {
        r.push_back(Point((-d - b * t1 - c * t2) / a, t1, t2));
        r.push_back(Point((-d - b * t2 - c * t3) / a, t2, t3));
        r.push_back(Point((-d - b * t3 - c * t1) / a, t3, t1));
      } else if (abs(b) > eps) {
        r.push_back(Point(t1, (-d - a * t1 - c * t2) / b, t2));
        r.push_back(Point(t2, (-d - a * t2 - c * t3) / b, t3));
        r.push_back(Point(t3, (-d - a * t3 - c * t1) / b, t1));
      } else if (abs(c) > eps) {
        r.push_back(Point(t1, t2, (-d - a * t1 - b * t2) / c));
        r.push_back(Point(t2, t3, (-d - a * t2 - b * t3) / c));
        r.push_back(Point(t3, t1, (-d - a * t3 - b * t1) / c));
      }
      return r;
    }
};


const int N = 4;
struct Matrix {
    double mat[N][N];

    Matrix() {zero();}

    void zero() {
      rep(i, N) rep(j, N) mat[i][j] = 0;
    }

    void one() {
      rep(i, N) rep(j, N) mat[i][j] = i==j;
    }

    Matrix operator+(Matrix B) {
      Matrix R;
      rep(i, N) rep(j, N) R.mat[i][j] = mat[i][j] + B.mat[i][j];
      return R;
    }

    Matrix operator*(Matrix B) {
      Matrix R;
      rep(i, 4) rep(j, 4) rep(k, 4)
        R.mat[i][j] += mat[i][k] * B.mat[k][j];
      return R;
    }

    friend Matrix operator*(double c, Matrix A) {
      Matrix R;
      rep(i, N) rep(j, N) R.mat[i][j] = c * A.mat[i][j];
      return R;
    }
};

Matrix translate(Point p) {
  Matrix R;
  R.one();
  R.mat[0][3] = p.x;
  R.mat[1][3] = p.y;
  R.mat[2][3] = p.z;
  return R;
}

Matrix scale(Point p) {
  Matrix R;
  R.mat[0][0] = p.x;
  R.mat[1][1] = p.y;
  R.mat[2][2] = p.z;
  R.mat[3][3] = 1;
  return R;
}

Matrix rotate(Point p, double alpha) {
  Matrix W;
  p = p.unit();
  W.mat[0][1] = -p.z;
  W.mat[0][2] = p.y;
  W.mat[1][0] = p.z;
  W.mat[1][2] = -p.x;
  W.mat[2][0] = -p.y;
  W.mat[2][1] = p.x;
  Matrix R;
  R.one();
  R.mat[3][3] = 0;
  R = R + sin(alpha) * W + (1 - cos(alpha)) * W * W;
  R.mat[3][3] = 1;
  return R;
}

Point operate(Matrix A, Point p) {
  return Point(
          A.mat[0][0] * p.x + A.mat[0][1] * p.y + A.mat[0][2] * p.z + A.mat[0][3],
          A.mat[1][0] * p.x + A.mat[1][1] * p.y + A.mat[1][2] * p.z + A.mat[1][3],
          A.mat[2][0] * p.x + A.mat[2][1] * p.y + A.mat[2][2] * p.z + A.mat[2][3]);
}

Plane operate(Matrix A, Plane q) {
  vector<Point> r = q.decompose();
  trav(&e, r) e = operate(A, e);
  return Plane(r[0], r[1], r[2]);
}


class L {
public:
  void solveOne(istream& in, ostream& out) {
    srand(time(NULL));
    int n, m, t;
    in >> n >> m >> t;
    vector<Point> p(n);
    rep(i, n) in >> p[i].x >> p[i].y >> p[i].z;
    vector<Plane> q(m);
    rep(i, m) in >> q[i].a >> q[i].b >> q[i].c >> q[i].d;
    Matrix R; R.one();
    rep(i, t) {
      string s;
      double a, b, c, alpha;
      in >> s >> a >> b >> c;
      if (s[0] == 'T') R = translate(Point(a, b, c)) * R;
      if (s[0] == 'R') {
        in >> alpha;
        R = rotate(Point(a, b, c), alpha * PI / 180) * R;
      }
      if (s[0] == 'S') {
        R = scale(Point(a, b, c)) * R;
      }
    }
    rep(i, n) {
      auto r = operate(R, p[i]);
      out << r.x << " " << r.y << " " << r.z << '\n';
    }
    rep(i, m) {
      auto r = operate(R, q[i]);
      out << r.a << " " << r.b << " " << r.c << " " << r.d << '\n';
    }
  }

  void solve(istream& in, ostream& out) {
    out.precision(2);
    out << fixed;
    int testNumber = 1;
    //in >> testNumber;
    re(tc, 1, testNumber+1) {
      //out << "Case #" << tc << ": ";
      solveOne(in, out);
    }
  }
};


int main() {
    //freopen("in", "r", stdin);
    //freopen("out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    L solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}