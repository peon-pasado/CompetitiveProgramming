/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag geometry, linear algebra, probability
 * @idea:
 *      - We can represent each plane by taking
 *      three of its points randomly.
 *
 *      - To reduce the number of operations,
 *      we can see each transformation as a matrix,
 *      in such a way that two operations can be
 *      concatenated by multiplying their associated matrices
 *
 *      - finally we can solve the three points to the 
 *      original plane, finding the normal vector and 
 *      multiplying by one of the three points.
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#include <bitset>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < mod? a+b : a+b-mod;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%mod;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a);
        a = mul(a, a);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 5e5 + 10;

template <class T> int sgn(T x) { return (x > 0) - (x < 0); }
template<class T>
struct Point {
    typedef Point P;
    T x, y, z;
    explicit Point(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}
    P operator+(P other) const {return P(x+other.x, y+other.y, z+other.z);}
    P operator-(P other) const {return P(x-other.x, y-other.y, z-other.z);}
    P operator*(T c) const {return P(x*c, y*c, z*c);}
    P operator/(T c) const {return P(x/c, y/c, z/c);}
    friend P operator*(T c, const P p) {return p*c;}
    T operator*(P other) const {return x*other.x + y*other.y + z*other.z;}
    T dot(P other) const {return (*this)*other;}
    Point cross(P other) const {
      return Point(y*other.z - z*other.y,
                   z*other.x - x*other.z,
                   x*other.y - y*other.x);
    }
    Point project(Point other) {
      return (*this) * this->dot(other) / this->dot(*this);
    }
    T norm2() const {return (*this)*(*this);}
    double norm() const {return sqrt((double)norm2());}
    double dist(P p) {return (p-(*this)).norm();}
    P unit() const {return *this/norm();} // makes dist()=1
    friend istream& operator>>(istream& is, P& other) {
      return is >> other.x >> other.y >> other.z;
    }
    friend ostream& operator<<(ostream& os, P other) {
      return os << other.x << " " << other.y << " " << other.z;
    }
};

template <class T>
struct Plane {
  T a, b, c, d;
  Point<T> p[3];
  Plane() {}
  Plane(Point<T> p[]) {
    auto q = (p[1] - p[0]).cross(p[2] - p[0]).unit();
    //x * q.x + y * q.y + z * q.z + d = 0;
    d = -q.dot(p[0]);
    a = q.x;
    b = q.y;
    c = q.z;
  }
  Plane(T a, T b, T c, T d): a(a), b(b), c(c), d(d) {
    auto dist = uniform_real_distribution<double>(0., 1.);
    if (abs(a) >= 1e-8) {
      for (int i = 0; i < 3; ++i) {
        auto r = dist(rng);
        auto q = dist(rng);
        p[i] = Point<T>(-(d + r * b + q * c)/a, r, q);
      }
    } else if (abs(b) >= 1e-8) {
      for (int i = 0; i < 3; ++i) {
        auto r = dist(rng);
        auto q = dist(rng);
        p[i] = Point<T>(r, -(d + r * a + q * c)/b, q);
      }
    } else {
      for (int i = 0; i < 3; ++i) {
        auto r = dist(rng);
        auto q = dist(rng);
        p[i] = Point<T>(r, q, -(d + r * a + q * b)/c);
      }
    }
  }
};

template<class T>
struct Transform {
    T mat[4][4];
    Transform() {
      zero();
    }

    void zero() {
      re(i, 0, 4) {
        re(j, 0, 4) {
          mat[i][j] = 0;
        }
      }
    }

    void one() {
      re(i, 0, 4) {
        re(j, 0, 4) {
          mat[i][j] = i==j;
        }
      }
    }

    void scale(Point<T> c) {
      mat[0][0] = c.x;
      mat[1][1] = c.y;
      mat[2][2] = c.z;
      mat[3][3] = 1;
    }

    void translate(Point<T> v) {
      one();
      mat[3][0] = v.x;
      mat[3][1] = v.y;
      mat[3][2] = v.z;
    }

    void rotate(Point<T> v, double angle) {
      angle = -angle * acos(-1) / 180.;
      auto cs = cos(angle);
      auto sn = sin(angle);
      v = v.unit();
      zero();
      mat[0][0] = cs + (1-cs) * v.x * v.x;
      mat[0][1] = (1-cs) * v.x * v.y - sn * v.z;
      mat[0][2] = (1-cs) * v.x * v.z + sn * v.y;
      mat[1][0] = (1-cs) * v.y * v.x + sn * v.z;
      mat[1][1] = cs + (1-cs) * v.y * v.y;
      mat[1][2] = (1-cs) * v.y * v.z - sn * v.x;
      mat[2][0] = (1-cs) * v.z * v.x - sn * v.y;
      mat[2][1] = (1-cs) * v.z * v.y + sn * v.x;
      mat[2][2] = cs + (1-cs) * v.z * v.z;
      mat[3][3] = 1;
    }

    Transform multiply(Transform other) {
      Transform R;
      R.zero();
      re(i, 0, 4) {
        re(j, 0, 4) {
          re(k, 0, 4) {
            R.mat[i][j] += mat[i][k] * other.mat[k][j];
          }
        }
      }
      return R;
    }

    Point<T> multiply(Point<T> v) {
      Point<T> r(mat[0][0] * v.x + mat[1][0] * v.y + mat[2][0] * v.z + mat[3][0],
                 mat[0][1] * v.x + mat[1][1] * v.y + mat[2][1] * v.z + mat[3][1],
                 mat[0][2] * v.x + mat[1][2] * v.y + mat[2][2] * v.z + mat[3][2]);
      return r;
    }
};

class UVA12303 {
public:
    void solveOne(istream& in, ostream& out) {
      int n, m, t;
      in >> n >> m >> t;
      vector<Point<double>> A(n);
      vector<Plane<double>> B;
      Transform<double> C;
      trav(&e, A) in >> e;
      re(i, 0, m) {
        double a, b, c, d;
        in >> a >> b >> c >> d;
        B.push_back(Plane<double>(a, b, c, d));
      }
      C.one();
      re(i, 0, t) {
        string type;
        Point<double> p;
        double angle;
        in >> type;
        if (type[0] == 'T') {
          in >> p;
          Transform<double> temp;
          temp.translate(p);
          C = C.multiply(temp);
        } else if (type[0] == 'S') {
          in >> p;
          Transform<double> temp;
          temp.scale(p);
          C = C.multiply(temp);
        } else {
          in >> p >> angle;
          Transform<double> temp;
          temp.rotate(p, angle);
          C = C.multiply(temp);
        }
      }
      re(i, 0, n) {
        out << C.multiply(A[i]) << '\n';
      }
      re(i, 0, m) {
        Point<double> temp[3];
        re(j, 0, 3) {
          temp[j] = C.multiply(B[i].p[j]);
        }
        Plane<double> res(temp);
        out << res.a << " " << res.b << " " << res.c << " " << res.d << '\n';
      }
    }

    void solve(istream& in, ostream& out) {
        out.precision(3);
        out << fixed;
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    //freopen("in", "r", stdin);
    //freopen("out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    UVA12303 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
