/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag dp, trie
 * @idea
 *      - we can notice that an optimal sequence decreases
 *      one by one and has a minimum point, then it grows
 *      one by one.
 *      - We can solve it with a similar way to find the 
 *      diameter of a tree with weights, on the trie.
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#include <bitset>
#include <stack>
#include <unordered_map>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < m? a+b : a+b-m;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%m;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a, m);
        a = mul(a, a, m);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 3e6 + 10;
string s;
map<char, int> trie[maxn];
bool term[maxn];
int memo[maxn];
int elems;

void add(string& r) {
  int root = 0;
  for (auto c : r) {
    if (!trie[root].count(c)) trie[root][c] = ++elems;
    root = trie[root][c];
  }
  term[root] = 1;
}

int dfs(int x) {
  int ans = 0;
  int a = 0, b = 0;
  int sum = 0;
  for (auto e : trie[x]) {
    sum += term[e.second];
    ans = max(ans, dfs(e.second));
    if (memo[e.second] + term[e.second] > a) {
      b = a;
      a = memo[e.second] + term[e.second];
    } else b = max(b, memo[e.second] + term[e.second]);
  }
  if (term[x]) memo[x] = a + max(0, sum-1);
  else memo[x] = 0;
  return max(ans, a + b + term[x] + max(0, sum - 2));
}

class COCI17Rima {
public:
    void solveOne(istream& in, ostream& out) {
      int n;
      in >> n;
      re(i, 0, n) {
        in >> s;
        reverse(all(s));
        add(s);
      }
      out << dfs(0) << endl;
    }

    void solve(istream& in, ostream& out) {
        out.precision(10);
        out << fixed;
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    //freopen("in", "r", stdin);
    //freopen("out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    COCI17Rima solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
