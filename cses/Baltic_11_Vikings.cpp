/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag bfs, dp
 * @idea
 *    - a position is reachable if the distance to
 *    that position is less than shorest distance 
 *    to a viking + large move (left, right, up or down).
 *
 *    - use a bfs for vikings and a dp to find left, right,
 *    up, down values. 
 *
 *   - use another bfs, ensure d[x][y] < min({up[x][y], down[x][y], left[x][y], right[x][y]}) 
 *
 *   - vikings' strategy is go to final position through the shortest route for you.
 *
**/

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#include <bitset>
#include <stack>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < m? a+b : a+b-m;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%m;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a, m);
        a = mul(a, a, m);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 700 + 10;
string mat[maxn];
int U[maxn][maxn];
int D[maxn][maxn];
int L[maxn][maxn];
int R[maxn][maxn];
int d[2][maxn][maxn];
bool vis[2][maxn][maxn];
int n, m;
const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};


class Baltic_11_Vikings {
public:
  void bfs(int sx, int sy, int idx) {
    if (sx == -1) return;
    queue<int> Q;
    auto add = [&](int x, int y) {
      Q.push(x);
      Q.push(y);
    };
    add(sx, sy);
    auto valid = [&](int x, int y)->bool {
      return min(x, y) >= 0 && x < n && y < m;
    };
    vis[idx][sx][sy] = 1;
    d[idx][sx][sy] = 0;
    while (!Q.empty()) {
      int qx = Q.front(); Q.pop();
      int qy = Q.front(); Q.pop();
      for (int i = 0; i < 4; ++i) {
        int nx = qx + dx[i];
        int ny = qy + dy[i];
        if (!valid(nx, ny)) continue;
        if (mat[nx][ny] == 'I') continue;
        if (vis[idx][nx][ny]) continue;
        if (d[idx^1][nx][ny] <= d[idx][qx][qy] + 1) continue;
        d[idx][nx][ny] = d[idx][qx][qy] + 1;
        vis[idx][nx][ny] = 1;
        add(nx, ny);
      }
    }
  }

  void solveOne(istream& in, ostream& out) {
    in >> n >> m;
    int sx = -1, sy = -1, vx = -1, vy = -1, fx = 0, fy = 0;
    for (int i = 0; i < n; ++i) {
      in >> mat[i];
      for (int j = 0; j < m; ++j) {
        if (mat[i][j] == 'Y') {
          sx = i;
          sy = j;
        }
        if (mat[i][j] == 'V') {
          vx = i;
          vy = j;
        }
        if (mat[i][j] == 'T') {
          fx = i;
          fy = j;
        }
      }
    }
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < m; ++j) {
        for (int k = 0; k < 2; ++k) {
          d[k][i][j] = inf;
        }
      }
    }
    memset(vis, 0, sizeof vis);
    bfs(vx, vy, 0);
    d[0][vx][vy] = 1;
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < m; ++j) {
        if (mat[i][j] == 'I') {
          U[i][j] = L[i][j] = inf;
          continue;
        }
        U[i][j] = d[0][i][j];
        if (i > 0) U[i][j] = min(U[i-1][j], U[i][j]);
        L[i][j] = d[0][i][j];
        if (j > 0) L[i][j] = min(L[i][j-1], L[i][j]);
      }
    }
    for (int i = n-1; i >= 0; --i) {
      for (int j = m-1; j >= 0; --j) {
        if (mat[i][j] == 'I') {
          D[i][j] = R[i][j] = inf;
          continue;
        }
        D[i][j] = d[0][i][j];
        if (i + 1 < n) D[i][j] = min(D[i][j], D[i+1][j]);
        R[i][j] = d[0][i][j];
        if (j + 1 < m) R[i][j] = min(R[i][j], R[i][j+1]);
      }
    }
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < m; ++j) {
        d[0][i][j] = min({L[i][j], R[i][j], D[i][j], U[i][j]});
      }
    }
    bfs(sx, sy, 1);
    bool answer = false;
    if (d[1][fx][fy] < inf) {
      answer = true;
    }
    out << (answer ? "YES" : "NO") << '\n';
  }

  void solve(istream& in, ostream& out) {
    out.precision(10);
    out << fixed;
    int testNumber = 1;
    //in >> testNumber;
    re(tc, 1, testNumber+1) {
      //out << "Case #" << tc << ": ";
      solveOne(in, out);
    }
  }
};


int main() {
    //freopen("in", "r", stdin);
    //freopen("out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    Baltic_11_Vikings solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
