/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @name csacademy - Path Inversions
 * @author Miguel Mini
 * @tag centroid decomposition
 * @idea
 *      - every valid path has its reverse,
 *      so every pair of vertices in a path adds one.
 *
 *      - use centroid decomposition to count k length paths.
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
const int mod = 1e9 + 7;
const int inf = 1.2e9;

int add(int a, int b) {
  return (a + b)%mod;
}

int mul(ll a, ll b) {
  return a * b%mod;
}

struct CentroidDecomposition {
    vector<vector<int>> T;
    vector<int> siz, P, rank;
    vector<bool> block;
    vector<vector<int>> dist;
    vector<int> res;
    vector<int> vis;
    int time;
    int root;
    int k;
    CentroidDecomposition(int n, int k):
      T(n)
      , k(k)
      , siz(n)
      , P(n, -1)
      , block(n)
    // , rank(n)
      , root(0)
    // , dist((int)log2(n) + 1, vector<int>(n))
      , vis(n)
      , time(0)
      , res(n)
    {}
    void addEdge(int a, int b) {
      T[a].emplace_back(b);
      T[b].emplace_back(a);
    }
    bool valid(int x, int p) {
      return x != p and not block[x];
    }
    int dfs(int x, int p=-1) {
      siz[x] = 1;
      for (int v : T[x]) {
        if (valid(v, p)) {
          siz[x] += dfs(v, x);
        }
      }
      return siz[x];
    }
    int get_centroid(int x, int p, int n) {
      for (int v : T[x]) {
        if (valid(v, p) and siz[v] > n>>1) {
          return get_centroid(v, x, n);
        }
      }
      return x;
    }
    void calc_dist(int x, int r, int p=-1, int h=0) {
      dist[r][x] = h;
      for (int v : T[x]) {
        if (valid(v, p)) {
          calc_dist(v, r, x, h+1);
        }
      }
    }
    int decompose(int x, int p=-1, int r=0) {
      int n = dfs(x);
      int cen = get_centroid(x, -1, n);
      // calc_dist(cen, r);
      // P[cen] = p;
      block[cen] = 1;
      // rank[cen] = r;
      time += 1;
      vis[0] = time;
      res[0] = 1;
      int ans = 0;
      for (auto v : T[cen]) {
        if (block[v]) continue;
        ans = add(ans, count_k(v, -1, 1, 0));
        count_k(v, -1, 1, 1);
      }
      for (auto v : T[cen]) {
        if (block[v]) continue;
        ans = add(ans, decompose(v, cen, r+1));
      }
      return ans;
    }
    int count_k(int x, int p, int h, int op) {
      if (vis[h] < time) res[h] = 0, vis[h] = time;
      int ans = 0;
      if (op == 1) {
        res[h] += 1;
      } else if (h <= k) {
        ans = add(ans, res[k - h]);
      }
      for (int v : T[x]) {
        if (!valid(v, p)) continue;
        ans = add(ans, count_k(v, x, h+1, op));
      }
      return ans;
    }
};


class A {
public:
    void solveOne(istream& in, ostream& out) {
      int n, k;
      in >> n >> k;
      CentroidDecomposition tree(n, k);
      re(i, 0, n-1) {
        int a, b;
        in >> a >> b;
        tree.addEdge(a-1, b-1);
      }
      out << mul(k *1ll*(k+1) / 2 % mod, tree.decompose(tree.root)) << endl;
    }

    void solve(istream& in, ostream& out) {
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	A solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}