/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Miguel Mini
 * @tag BIT2D, sorting, sweep_line
 * @idea
 *      - we can represent the roads as colorful points on
 *      the plane where the point color represents a breed, 
 *      then we can add the color dimension and go back down 
 *      to 2d with a sweep line and the help of a BIT. 
 */

#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <ctime>
#include <cstring>
#include <complex>
#include <climits>
#include <iomanip>
#include <numeric>
#include <functional>
#include <fstream>
#include <cassert>
#include <chrono>
#include <random>
#include <bitset>
#include <stack>
#define sz(x) (int)x.size()
#define trav(v, x) for (auto v : x)
#define re(x, y, z) for (int x=y; x<z; ++x)
#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define set_to(x, v) fill(all(x), v)
#define eb emplace_back
#define lso(x) ((x)&-(x))
#define mset(m ,v) memset(m, v, sizeof(m))
using namespace std;
using ll = long long;
using ii = pair<int, int>;
using vi = vector<int>;
using vii = vector<ii>;
using si = set<int>;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int mod = 1e9 + 7;

int add(int a, int b, int m=mod) {
    return a+b < mod? a+b : a+b-mod;
}

int mul(ll a, ll b, int m=mod) {
    return a*b%mod;
}

int ex(int a, int b, int m=mod) {
    int r=1;
    while (b > 0) {
        if (b&1) r = mul(r, a);
        a = mul(a, a);
        b >>= 1;
    }
    return r;
}

const int inf = 1.2e9;
const int maxn = 5e5 + 10;

struct FT {
    vector<ll> s;
    FT(int n) : s(n) {}
    void update(int pos, ll dif) { // a[pos] += dif
      for (; pos < sz(s); pos |= pos + 1) s[pos] += dif;
    }
    ll query(int pos) { // sum of values in [0, pos)
      ll res = 0;
      for (; pos > 0; pos &= pos - 1) res += s[pos-1];
      return res;
    }
    int lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum
      // Returns n if no sum is >= sum, or -1 if empty sum is.
      if (sum <= 0) return -1;
      int pos = 0;
      for (int pw = 1 << 25; pw; pw >>= 1) {
        if (pos + pw <= sz(s) && s[pos + pw-1] < sum)
          pos += pw, sum -= s[pos-1];
      }
      return pos;
    }
};

struct FT2 {
    vector<vi> ys; vector<FT> ft;
    FT2(int limx) : ys(limx) {}
    void fakeUpdate(int x, int y) {
      for (; x < sz(ys); x |= x + 1) ys[x].push_back(y);
    }
    void init() {
      trav(v, ys) sort(all(v)), ft.emplace_back(sz(v));
    }
    int ind(int x, int y) {
      return (int)(lower_bound(all(ys[x]), y) - ys[x].begin());
    }
    void update(int x, int y, ll dif) {
      for (; x < sz(ys); x |= x + 1)
        ft[x].update(ind(x, y), dif);
    }
    ll query(int x, int y) {
      ll sum = 0;
      for (; x; x &= x - 1)
        sum += ft[x-1].query(ind(x-1, y));
      return sum;
    }
};

class feb17_platinum3 {
public:
    void solveOne(istream& in, ostream& out) {
      int n, k;
      in >> n >> k;
      vi pos_1(n+1), pos_2(n+1);
      re(i, 0, n) {
        int x;
        in >> x;
        pos_1[x] = i + 1;
      }
      re(i, 0, n) {
        int x;
        in >> x;
        pos_2[x] = i + 1;
      }
      FT2 f(n + 2);
      re(i, 1, n+1) {
        f.fakeUpdate(pos_2[i], i);
      }
      struct Point {
          int x, y, z;
      };
      vector<Point> p(n);
      re(i, 1, n+1) p[i-1] = {pos_1[i], pos_2[i], i};
      sort(all(p), [](Point a, Point b) {
        return ii(-a.x, a.y) < ii(-b.x, b.y);
      });
      f.init();
      ll ans = 0;
      for (int i = 0; i < n; ++i) {
        int temp = 0;
        temp += f.query(p[i].y + 1, 1e9);
        temp -= f.query(p[i].y + 1, p[i].z + k + 1) - f.query(p[i].y, p[i].z - k);
        f.update(p[i].y, p[i].z, 1);
      }
      FT2 g(n + 2);
      re(i, 1, n+1) {
        g.fakeUpdate(n - pos_2[i] + 1, i);
      }
      re(i, 1, n+1) p[i-1] = {pos_1[i], n - pos_2[i] + 1, i};
      sort(all(p), [](Point a, Point b) {
        return ii(a.x, b.x) < ii(b.x, b.y);
      });
      g.init();
      for (int i = 0; i < n; ++i) {
        ans += g.query(p[i].y + 1, 1e9);
        ans -= g.query(p[i].y + 1, p[i].z + k + 1) - g.query(p[i].y, p[i].z - k);
        g.update(p[i].y, p[i].z, 1);
      }
      out << ans << endl;
    }

    void solve(istream& in, ostream& out) {
        out.precision(10);
        out << fixed;
        int testNumber = 1;
        //in >> testNumber;
        re(tc, 1, testNumber+1) {
            //out << "Case #" << tc << ": ";
            solveOne(in, out);
        }
    }
};


int main() {
    freopen("friendcross.in", "r", stdin);
    freopen("friendcross.out", "w", stdout);
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    feb17_platinum3 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
